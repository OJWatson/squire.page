#' Generate parameter draws from a pmcmc run
#' Code take from squire:::sample_pmcmc()
#' @param out Output of `squire::pmcmc`
#' @param draws Number of draws from mcmc chain. Default = 10
#' @export
generate_parameters <- function(out, draws = 10){
  #set up parameters
  pmcmc_results <- out$pmcmc_results
  n_trajectories <- draws
  burnin <- 1000
  if("chains" %in% names(out$pmcmc_results)) {
    n_chains <- length(out$pmcmc_results$chains)
  } else {
    n_chains <- 1
  }
  n_particles <- 2
  forecast_days <- 0

  #code from squire: Will need updating if squire undergoes changes
  squire:::assert_pos_int(n_chains)
  if (n_chains == 1) {
    squire:::assert_custom_class(pmcmc_results, "squire_pmcmc")
  } else {
    squire:::assert_custom_class(pmcmc_results, "squire_pmcmc_list")
  }
  squire:::assert_pos_int(burnin)
  squire:::assert_pos_int(n_trajectories)
  squire:::assert_pos_int(n_particles)
  squire:::assert_pos_int(forecast_days)
  if (n_chains > 1) {
    res <- squire::create_master_chain(x = pmcmc_results, burn_in = burnin)
  } else if (n_chains == 1 & burnin > 0) {
    res <- pmcmc_results$results[-seq_along(burnin), ]
  } else {
    res <- pmcmc_results$results
  }
  res <- unique(res)
  probs <- exp(res$log_posterior)
  probs <- probs/sum(probs)
  drop <- 0.9
  while (any(is.na(probs))) {
    probs <- exp(res$log_posterior * drop)
    probs <- probs/sum(probs)
    drop <- drop^2
  }
  params_smpl <- sample(x = length(probs), size = n_trajectories,
                        replace = TRUE, prob = probs)
  params_smpl <- res[params_smpl, !grepl("log", colnames(res))]
  #add adjustment for if using weekly data
  if("date" %in% names(pmcmc_results$inputs$data)){
    params_smpl$start_date <- squire:::offset_to_start_date(pmcmc_results$inputs$data$date[1],
                                                            round(params_smpl$start_date))
  } else {
    params_smpl$start_date <- squire:::offset_to_start_date(pmcmc_results$inputs$data$week_start[1],
                                                            round(params_smpl$start_date))
  }
  pars.list <- split(params_smpl, 1:nrow(params_smpl))
  names(pars.list) <- rep("pars", length(pars.list))
  #return the parameters
  return(pars.list)
}

#' A function to reduce redundancy in generate programmes
#' @noRd
generate_draws_inner <- function(out, pars.list, draws = 10, parallel, interventions = NULL, excess = FALSE){
  # handle for no death days
  if(!("pmcmc_results" %in% names(out))) {
    message("`out` was not generated by pmcmc as no deaths for this country. \n",
            "Returning the original object, which assumes epidemic seeded on date ",
            "fits were run")
    return(out)
  }

  # grab information from the pmcmc run
  pmcmc <- out$pmcmc_results
  squire_model <- out$pmcmc_results$inputs$squire_model
  country <- out$parameters$country
  population <- out$parameters$population
  data <- out$pmcmc_results$inputs$data

  # are we drawing in parallel
  if (parallel) {
    suppressWarnings(future::plan(future::multisession()))
  }

  if(!is.null(interventions)){
    #if making a change add that intervention here
    pmcmc$inputs$interventions <- interventions
  }else{
    #else this is the interventions that come with the object
    interventions <- out$interventions
  }

  #--------------------------------------------------------
  # Section 3 of pMCMC Wrapper: Sample PMCMC Results
  #--------------------------------------------------------
  #rename objects to their sample_pmcmc equivalent (so that it is simple to update
  #this code)
  pmcmc_results <- pmcmc
  n_particles <- 2
  forecast_days <- 0
  if(excess){
    log_likelihood <- excess_log_likelihood
  } else {
    log_likelihood <- squire:::calc_loglikelihood
  }
  replicates <- draws
  #recreate params_smpl object
  params_smpl <- rbind(pars.list[[1]], pars.list[[2]])

  #instead of using squire:::sample_pmcmc we use the pars.list values provided
  #the following code is taken from squire:::sample_pmcmc and will need updating
  #if squire undergoes major changes
  message("Sampling from pMCMC Posterior...")
  if (Sys.getenv("SQUIRE_PARALLEL_DEBUG") == "TRUE") {
    traces <- purrr::map(.x = pars.list, .f = log_likelihood,
                         data = pmcmc_results$inputs$data, squire_model = pmcmc_results$inputs$squire_model,
                         model_params = pmcmc_results$inputs$model_params,
                         pars_obs = pmcmc_results$inputs$pars_obs, n_particles = n_particles,
                         forecast_days = forecast_days, interventions = pmcmc_results$inputs$interventions,
                         Rt_args = pmcmc_results$inputs$Rt_args, return = "full")
  } else{
    traces <- furrr::future_map(.x = pars.list, .f = log_likelihood,
                                data = pmcmc_results$inputs$data, squire_model = pmcmc_results$inputs$squire_model,
                                model_params = pmcmc_results$inputs$model_params,
                                pars_obs = pmcmc_results$inputs$pars_obs, n_particles = n_particles,
                                forecast_days = forecast_days, interventions = pmcmc_results$inputs$interventions,
                                Rt_args = pmcmc_results$inputs$Rt_args, return = "full",
                                .progress = TRUE, .options = furrr::furrr_options(seed = NULL))
  }
  num_rows <- unlist(lapply(traces, nrow))
  max_rows <- max(num_rows)
  seq_max <- seq_len(max_rows)
  max_date_names <- rownames(traces[[which.max(unlist(lapply(traces,
                                                             nrow)))]])
  trajectories <- array(NA, dim = c(max_rows, ncol(traces[[1]]),
                                    length(traces)), dimnames = list(max_date_names, colnames(traces[[1]]),
                                                                     NULL))
  for (i in seq_len(length(traces))) {
    trajectories[utils::tail(seq_max, nrow(traces[[i]])), , i] <- traces[[i]]
  }
  pmcmc_samples <- list(trajectories = trajectories, sampled_PMCMC_Results = params_smpl,
              inputs = list(squire_model = pmcmc_results$inputs$squire_model,
                            model_params = pmcmc_results$inputs$model_params,
                            interventions = pmcmc_results$inputs$interventions,
                            data = pmcmc_results$inputs$data, pars_obs = pmcmc_results$inputs$pars_obs))
  class(pmcmc_samples) <- "squire_sample_PMCMC"


  #--------------------------------------------------------
  # Section 4 of pMCMC Wrapper: Tidy Output
  #--------------------------------------------------------

  # create a fake run object and fill in the required elements
  r <- squire_model$run_func(country = country,
                             contact_matrix_set = pmcmc$inputs$model_params$contact_matrix_set,
                             tt_contact_matrix = pmcmc$inputs$model_params$tt_matrix,
                             hosp_bed_capacity = pmcmc$inputs$model_params$hosp_bed_capacity,
                             tt_hosp_beds = pmcmc$inputs$model_params$tt_hosp_beds,
                             ICU_bed_capacity = pmcmc$inputs$model_params$ICU_bed_capacity,
                             tt_ICU_beds = pmcmc$inputs$model_params$tt_ICU_beds,
                             population = population,
                             day_return = TRUE,
                             replicates = 1,
                             time_period = nrow(pmcmc_samples$trajectories))

  # and add the parameters that changed between each simulation, i.e. posterior draws
  r$replicate_parameters <- pmcmc_samples$sampled_PMCMC_Results

  # as well as adding the pmcmc chains so it's easy to draw from the chains again in the future
  r$pmcmc_results <- pmcmc

  # then let's create the output that we are going to use
  names(pmcmc_samples)[names(pmcmc_samples) == "trajectories"] <- "output"
  dimnames(pmcmc_samples$output) <- list(dimnames(pmcmc_samples$output)[[1]], dimnames(r$output)[[2]], NULL)
  r$output <- pmcmc_samples$output

  # and adjust the time as before
  full_row <- match(0, apply(r$output[,"time",],2,function(x) { sum(is.na(x)) }))
  saved_full <- r$output[,"time",full_row]
  if("date" %in% names(data)){
    for(i in seq_len(replicates)) {
      na_pos <- which(is.na(r$output[,"time",i]))
      full_to_place <- saved_full - which(rownames(r$output) == as.Date(max(data$date))) + 1L
      if(length(na_pos) > 0) {
        full_to_place[na_pos] <- NA
      }
      r$output[,"time",i] <- full_to_place
    }
  } else {
    for(i in seq_len(replicates)) {
      na_pos <- which(is.na(r$output[,"time",i]))
      full_to_place <- saved_full - which(rownames(r$output) == as.Date(max(data$week_start))) + 1L
      if(length(na_pos) > 0) {
        full_to_place[na_pos] <- NA
      }
      r$output[,"time",i] <- full_to_place
    }

  }

  # second let's recreate the output
  r$model <- pmcmc_samples$inputs$squire_model$odin_model(
    user = pmcmc_samples$inputs$model_params, unused_user_action = "ignore"
  )

  # we will add the interventions here so that we know what times are needed for projection
  r$interventions <- interventions

  # and fix the replicates
  r$parameters$replicates <- replicates
  r$parameters$time_period <- as.numeric(diff(as.Date(range(rownames(r$output)))))
  r$parameters$dt <- pmcmc$inputs$model_params$dt

  return(r)
}

#' Generate Draws from pmcmc run
#'
#' @param out Output of `squire::pmcmc`
#' @param pars.list Output of generate_parameters().
#' @param draws Number of draws from mcmc chain. Default = 10
#' @param parallel Are simulations done in parallel? Default = TRUE
#' @param noInfectionProtect Should the vaccine prevent infections. Default = FALSE
#' @param excess Use the excess loglikelihood? Default = FALSE
#' @export
generate_draws <- function(out, pars.list, draws = 10, parallel = TRUE, noInfectionProtect = FALSE, excess = FALSE) {
  if(noInfectionProtect){
    out$odin_parameters$vaccine_efficacy_infection <- matrix(0.5,
                                                             nrow = nrow(out$odin_parameters$vaccine_efficacy_infection),
                                                             ncol = ncol(out$odin_parameters$vaccine_efficacy_infection))
    #scale up protection against disease to keep the same efficacy
    if(any(out$interventions$date_vaccine_efficacy_infection_change != out$interventions$date_vaccine_efficacy_disease_change)){
      "Different efficacy change times against disease and infection"
    }
    trueEff <-
      Map("+",
          out$interventions$vaccine_efficacy_infection,
          Map("*",
              Map("-", 1, out$interventions$vaccine_efficacy_infection),
              out$interventions$vaccine_efficacy_disease
          )
      )
    out$parameters$vaccine_efficacy_disease <- trueEff
    out$interventions$vaccine_efficacy_disease <- trueEff
    out$pmcmc_results$inputs$interventions$vaccine_efficacy_disease <- trueEff

    #set infection efficacy in interventions
    out$pmcmc_results$inputs$interventions$vaccine_efficacy_infection <- lapply(
      out$pmcmc_results$inputs$interventions$vaccine_efficacy_infection, function(x) {
        rep(0,17)
        })
    out$interventions$vaccine_efficacy_infection <- lapply(
      out$pmcmc_results$inputs$interventions$vaccine_efficacy_infection, function(x) {
        rep(0,17)
      })
    # the calc_loglikelihood function samples from the model_params for vaccine pars rather than recalculating
    # so we need to update this here
    out$pmcmc_results$inputs$model_params$vaccine_efficacy_infection <- nimue:::format_ve_i_for_odin(
      vaccine_efficacy_infection = out$interventions$vaccine_efficacy_infection,
      tt_vaccine_efficacy_infection = out$pmcmc_results$inputs$model_params$tt_vaccine_efficacy_infection
      )

    out$pmcmc_results$inputs$model_params$prob_hosp <- nimue:::format_ve_d_for_odin(
      vaccine_efficacy_disease = trueEff,
      tt_vaccine_efficacy_disease = out$pmcmc_results$inputs$model_params$tt_vaccine_efficacy_disease,
      prob_hosp = nimue:::probs$prob_hosp)

    #set relative infectiousness to 1
    out$pmcmc_results$inputs$model_params$rel_infectiousness_vaccinated <-
      matrix(1,
             nrow = nrow(out$pmcmc_results$inputs$model_params$rel_infectiousness_vaccinated),
             ncol = ncol(out$pmcmc_results$inputs$model_params$rel_infectiousness_vaccinated)
             )
    out$odin_parameters$rel_infectiousness_vaccinated <-
      matrix(1,
             nrow = nrow(out$odin_parameters$rel_infectiousness_vaccinated),
             ncol = ncol(out$odin_parameters$rel_infectiousness_vaccinated)
      )
    out$parameters$rel_infectiousness_vaccinated <-
      rep(1, length(out$parameters$rel_infectiousness_vaccinated))
  }
  r <- generate_draws_inner(out, pars.list, draws, parallel, excess = excess)
  return(r)
}

#' Generate Draws from pmcmc run with a counter factual based on vaccines
#'
#' @param out Output of `squire::pmcmc`
#' @param pars.list Output of generate_parameters().
#' @param assignedVaccine The number of doses given to the country at this date.
#' @param vaccineStart The date the vaccination is to start. Should be a character
#' in the format "YYYY-MM-DD". Default = NULL
#' @param draws Number of draws from mcmc chain. Default = 10
#' @param parallel Are simulations done in parallel? Default = TRUE
#' @param excess Use the excess loglikelihood? Default = FALSE
#' @export
generate_draws_counterfactual <- function(out, pars.list, assignedVaccine,
                                          vaccineStart = NULL,
                                          draws = 10, parallel = TRUE,
                                          excess = excess) {
  #get interventions
  interventions <- out$interventions
  #get original start date if one not given
  #the current date (one day before so that we hit correct number on the last day)
  if("date" %in% names(out$pmcmc_results$inputs$data)){
    modelEnd <- max(out$pmcmc_results$inputs$data$date) - 1
  } else {
    modelEnd <- max(out$pmcmc_results$inputs$data$week_end) - 1
  }
  if(is.na(vaccineStart)){
    if(sum(interventions$max_vaccine) == 0 & assignedVaccine != 0){
      stop("This country has not begun to give vaccinations, please provide a
           vaccine start date")
    }
    vaccineStart <- min(interventions$date_vaccine_change, modelEnd - 1)
    #the minimum is between these to prevent errors in countries that have started
    #vaccinations on the last date
  }
  # allow number of vaccines to change every day from this time to today
  if(as.Date(vaccineStart) >= modelEnd){
    #a check for if there isn't data up to the end data (for example if using weekly excess)
    date_vaccine_change <- seq(modelEnd - 1, modelEnd, by = 1)
  } else{
    date_vaccine_change <- seq(as.Date(vaccineStart), modelEnd, by = 1)
  }
  # now assign vaccines so that they'll sum to the assignVaccine
  max_vaccine <- seq(0, 2*assignedVaccine/(length(date_vaccine_change)+1),
                                  length.out = length(date_vaccine_change) + 1)

  #add to interventions
  interventions$max_vaccine <- max_vaccine
  interventions$date_vaccine_change <- date_vaccine_change

  #generate results
  r <- generate_draws_inner(out, pars.list, draws, parallel, interventions,
                            excess = excess)

  return(r)
}
